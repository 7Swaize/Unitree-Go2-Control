import os
import sys
import time
from enum import Enum

import cv2

ROOT = os.path.abspath(os.path.join(os.path.dirname(__file__), "..", ".."))
sys.path.insert(0, ROOT)

from aruko_helpers import *
from unitree_control.core.unitree_control_core import UnitreeGo2Controller
from unitree_control.core.module_registry import ModuleType
from unitree_control.video_control.camera_source import CameraSourceFactory


# ============================================================================
# MARKER DEFINITIONS
# ============================================================================

class MarkerCommand(Enum):
    """Commands that markers represent."""
    STOP = 0
    RIGHT_90_DEGREES = 1
    LEFT_90_DEGREES = 2
    ROTATE_180_DEGREES = 3
    DUMMY_1 = 4



# ============================================================================
# GLOBAL CONTROLLER INSTANCE
# ============================================================================

# Unitree controller instance used to access modules
unitree_controller = None



# ============================================================================
# SETUP AND CLEANUP
# ============================================================================

# Initializes the unitree controller for use in this script
def setup():
    global unitree_controller
    
    # Create the controller in SDK mode because we want to use functionalities of the robot
    unitree_controller = UnitreeGo2Controller(use_sdk=True)
    # Register cleanup function to be called on exit after controller shutdown
    unitree_controller.register_cleanup_callback(cleanup)
    
    # Add audio and video capabilities
    unitree_controller.add_module(ModuleType.AUDIO)
    unitree_controller.add_module(ModuleType.VIDEO, camera_source=CameraSourceFactory.create_sdk_camera()) # Use robot's built-in camera (sdk camera)
    
    # Start video streaming and display streaming endpoint
    unitree_controller.video.start_stream_server()
    print(f"WebRTC streaming at: http://{unitree_controller.video.get_stream_server_local_ip()}:{unitree_controller.video.get_stream_server_port()}")
    
    # Create window for camera feed
    cv2.namedWindow("Robot Camera", cv2.WINDOW_NORMAL)


# Cleans up resources in this script on exit
def cleanup():
    cv2.destroyAllWindows()
    time.sleep(1)




# ============================================================================
# CAMERA HELPERS
# ============================================================================

# Gets a single frame from the robot's camera
def get_camera_frame():
    code, image = unitree_controller.video.get_frames()
    if code != 0 or image is None:
        return None
    
    return image


# Displays a single frame using OpenCV and sends it to the video streamer
def show_camera_frame(image):
    cv2.imshow("Robot Camera", image)
    unitree_controller.video.send_frame(image)



# ============================================================================
# HELPER FUNCTIONS
# ============================================================================

# Checks if the user has requested to stop via ESC key or shutdown signal
def check_for_exit():
    # User pressed ESC key
    if cv2.waitKey(1) & 0xFF == 27:
        return True
    
    # Shutdown requested from controller
    if unitree_controller.is_shutdown_requested():
        return True
    
    return False



# ============================================================================
# MARKER DETECTION
# ============================================================================

# Look for a specific marker in the current camera frame.
def find_marker_in_frame(image, target_marker_id):
    corners, ids, _ = get_aruko_marker(image)
    marker_id, bounds, center, h_offset, area = extract_data_from_marker_by_id(
        image, corners, ids, target_marker_id
    )
    
    found = (marker_id == target_marker_id)
    return found, marker_id, bounds, center, h_offset, area

# Rotate the dog to search for a specific marker.
def scan_for_marker(target_marker_id, max_sweeps=8):
    unitree_controller.audio.play_audio(f"Searching for marker {target_marker_id}")
    
    search_angle = 360  # Full rotation
    rotate_step = 1.5   # Degrees to rotate each step
    current_angle = 0
    sweeps_done = 0
    
    while sweeps_done < max_sweeps:
        # Check for exit conditions and raise exception when exit is requested
        if check_for_exit():
            raise KeyboardInterrupt()

        # Get the latest camera frame
        image = get_camera_frame()
        if image is None:
            continue
        
        # Check if we found the marker
        found, marker_id, bounds, _, _, _ = find_marker_in_frame(image, target_marker_id)
        
        # Draw search info on screen
        cv2.putText(image, f"Target: {target_marker_id}", (5, 30),
                    cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255, 255, 0), 2)
        cv2.putText(image, f"Sweep: {sweeps_done + 1}/{max_sweeps}", (5, 60),
                    cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255, 255, 255), 2)
        cv2.putText(image, f"Angle: {current_angle:.1f}", (5, 90),
                    cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255, 255, 255), 2)
        
        # If found, highlight it on the frame and announce
        if found:
            cv2.putText(image, "FOUND!", (bounds[0][0], bounds[0][1] - 10),
                        cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0, 255, 0), 2)
            draw_marker_bounds(image, bounds, color=(0, 255, 0))
            show_camera_frame(image)
            
            unitree_controller.movement.stop()
            unitree_controller.audio.play_audio(f"Marker {target_marker_id} found!")
            return True
        
        show_camera_frame(image)
        
        # Continue rotating
        unitree_controller.movement.rotate(rotate_step)
        current_angle += rotate_step
        
        # Check if we've completed a full sweep
        if current_angle >= search_angle:
            sweeps_done += 1
            current_angle = 0

    
    unitree_controller.movement.stop()
    unitree_controller.audio.play_audio(f"Marker {target_marker_id} not found.")
    
    return False



# ============================================================================
# MOVEMENT FUNCTIONS
# ============================================================================

# Rotate the dog to center on the marker.
def align_to_marker(h_offset, h_offset_threshold, rotate_step):
    is_centered = abs(h_offset) <= h_offset_threshold
    
    if is_centered:
        return True
    
    if h_offset < -h_offset_threshold:
        unitree_controller.movement.rotate(-rotate_step)  # Turn left
    elif h_offset > h_offset_threshold:
        unitree_controller.movement.rotate(rotate_step)   # Turn right
    
    return False


# Calculate how fast to move forward based on distance to marker. Slows down as the dog gets closer.
def calculate_forward_speed(area, area_threshold, forward_step):
    slowdown_start = area_threshold * 0.6
    
    if area >= slowdown_start:
        progress = (area - slowdown_start) / (area_threshold - slowdown_start)
        scale = max(0.1, (1 - progress))
        return forward_step * scale
    
    return forward_step


# Draw tracking information on the camera feed.
def draw_marker_tracking_info(image, marker_id, bounds, h_offset, area, is_centered):
    draw_marker_bounds(image, bounds, 
                      color=(0, 255, 0) if is_centered else (0, 165, 255))
    
    cv2.putText(image, f"ID: {marker_id}", (5, 30),
                cv2.FONT_HERSHEY_SIMPLEX, 0.8, (0, 255, 0), 2)
    cv2.putText(image, f"Offset: {h_offset}", (5, 60),
                cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0, 255, 255), 2)
    cv2.putText(image, f"Area: {int(area)}", (5, 90),
                cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0, 255, 255), 2)
    cv2.putText(image, "Centered" if is_centered else "Aligning...", (5, 120),
                cv2.FONT_HERSHEY_SIMPLEX, 0.6, 
                (0, 255, 0) if is_centered else (0, 165, 255), 2)


# Draw a warning on the camera feed when the marker is lost.
def draw_lost_marker_warning(image, target_marker_id):
    cv2.putText(image, f"LOST MARKER! (Looking for {target_marker_id})", 
                (5, 30), cv2.FONT_HERSHEY_SIMPLEX, 0.8, (0, 0, 255), 2)


# Navigate the dog toward a detected marker until it's close enough.
def walk_to_marker(target_marker_id):
    unitree_controller.audio.play_audio(f"Moving toward marker {target_marker_id}")
    
    h_offset_threshold = 50      # How centered the marker needs to be (pixels)
    area_threshold = 60000       # How large the marker needs to be (close enough)
    forward_step = 2             # Base movement speed
    rotate_step = 1              # Rotation speed for alignment
    
    user_stopped = False
    reached_marker = False
    
    while not user_stopped and not reached_marker:
        # Check for exit conditions and raise exception when exit is requested
        if check_for_exit():
            raise KeyboardInterrupt()
        
        # Get the latest camera frame
        image = get_camera_frame()
        if image is None:
            continue
        

        # Find the marker
        found, marker_id, bounds, center, h_offset, area = find_marker_in_frame(
            image, target_marker_id
        )
        
        # Handle lost marker
        if not found:
            draw_lost_marker_warning(image, target_marker_id)
            show_camera_frame(image)

            continue
        

        # Try to align to marker
        is_centered = align_to_marker(h_offset, h_offset_threshold, rotate_step)
        
        # Move forward only when centered
        if is_centered:
            # Check if we've arrived
            if area >= area_threshold:
                unitree_controller.movement.stop()
                unitree_controller.audio.play_audio(f"Arrived at marker {target_marker_id}!")
                reached_marker = True
            else:
                # Move forward at appropriate speed
                step = calculate_forward_speed(area, area_threshold, forward_step)
                unitree_controller.movement.move(step)
        
        # Update display
        draw_marker_tracking_info(image, marker_id, bounds, h_offset, area, is_centered)
        show_camera_frame(image)
    
    unitree_controller.movement.stop()
    return reached_marker


# Move the dog backward for a certain number of steps.
def back_up(steps=35):
    for _ in range(steps):
        # Check for exit conditions and raise exception when exit is requested
        if check_for_exit():
            raise KeyboardInterrupt()

        unitree_controller.movement.move(-1)
        
        # Update camera display
        image = get_camera_frame()
        if image is not None:
            show_camera_frame(image)
        
        time.sleep(0.02)
    
    unitree_controller.movement.stop()



# ============================================================================
# MARKER RESPONSE LOGIC
# ============================================================================

# Execute a command based on the marker ID.
def respond_to_marker(marker_id):
    unitree_controller.audio.play_audio(f"Responding to marker {marker_id}")
    
    # STOP command
    if marker_id == MarkerCommand.STOP.value:
        unitree_controller.audio.play_audio("STOP command received")
        unitree_controller.movement.stop()
        time.sleep(0.5)
        return True
    
    # Turn 90 degrees left or right
    elif marker_id in (MarkerCommand.LEFT_90_DEGREES.value, MarkerCommand.RIGHT_90_DEGREES.value):
        rotation_steps = 160  # Number of steps for 90 degrees
        rotate_direction = 1 if marker_id == MarkerCommand.RIGHT_90_DEGREES.value else -1
        
        for _ in range(rotation_steps):
            # Check for exit conditions and raise exception when exit is requested
            if check_for_exit():
                raise KeyboardInterrupt()

            unitree_controller.movement.rotate(rotate_direction)
            time.sleep(0.02)
        
        unitree_controller.movement.stop()
        time.sleep(1)
    
    # Turn 180 degrees
    elif marker_id == MarkerCommand.ROTATE_180_DEGREES.value:
        rotation_steps = 320  # Number of steps for 180 degrees
        
        for _ in range(rotation_steps):
            # Check for exit conditions and raise exception when exit is requested
            if check_for_exit():
                raise KeyboardInterrupt()
            
            unitree_controller.movement.rotate(1)
            time.sleep(0.02)
        
        unitree_controller.movement.stop()
        time.sleep(1)
    
    return False



# ============================================================================
# MAIN PROGRAM
# ============================================================================

# Main program: search for each marker in sequence, approach it, back up, and optionally respond to its command.
def run_marker_sequence():
    # List of markers to find in order
    markers_to_find = [
        MarkerCommand.STOP,
        MarkerCommand.RIGHT_90_DEGREES,
        MarkerCommand.LEFT_90_DEGREES,
        MarkerCommand.ROTATE_180_DEGREES,
        MarkerCommand.DUMMY_1,
    ]
    
    try:
        # Process each marker in sequence
        for marker in markers_to_find:
            marker_id = marker.value
            
            # Step 1: Scan for the marker
            found = scan_for_marker(marker_id, max_sweeps=8)
            
            if not found:
                unitree_controller.audio.play_audio(f"Marker {marker_id} not found, skipping...")
                continue
            
            # Step 2: Walk to the marker
            reached = walk_to_marker(marker_id)
            
            if not reached:
                unitree_controller.audio.play_audio(f"Failed to reach marker {marker_id}, skipping...")
                continue
            
            # Step 3: Back up after reaching marker
            time.sleep(1.5)
            back_up(steps=35)
            time.sleep(1.5)
            
            # Step 4: Respond to marker command (currently disabled)
            # Uncomment the lines below to enable marker responses:
            # should_stop = respond_to_marker(marker_id)
            # if should_stop:
            #     break
        
        # Finish up
        unitree_controller.movement.stop()
        time.sleep(1)
        unitree_controller.movement.stand_down()
        time.sleep(1)
        
        unitree_controller.audio.play_audio("All markers processed successfully!")
    
    except KeyboardInterrupt:
        print("Keyboard Interrupt detected")
    except Exception as e:
        print(f"Unhandled error: {e}")
    finally:
        # We want to make sure to always safe shutdown the controller
        unitree_controller.safe_shutdown()



if __name__ == "__main__":
    setup()
    run_marker_sequence()